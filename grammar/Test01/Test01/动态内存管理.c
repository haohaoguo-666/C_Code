#define _CRT_SECURE_NO_WARNINGS 1
#include <stdlib.h>
#include<stdlib.h>
#include<errno.h>

//malloc
//这个函数的作用就是在堆区内开辟以字节为单位的空间，具体开辟多大，取决于我们在形参列表中填入的数字。
//同时，这个函数的返回值是一个void* 指针。


int main()
{
	int* p = (int*)malloc(40);
	int* ptr;
	if (p == NULL)
	{
		printf("%s\n", strerror(errno));
		return 1;
	}
	else
	{
		ptr = p;
	}
	//使用：非常类似于数组的使用，几乎是一致的。
	for( int i = 0; i < 10; i++)
	{
		ptr[i] = i;
	}
	//使用结束后：
	free(p);//释放空间内存，这个函数一会儿讲
	p = NULL;
	ptr = NULL;
	return 0;
}
//我们将开辟的空间的地址强制转换为整型指针，然后再用一个整形指针接收。但是我们知道，开辟的空间过大时，可能会导
//致空间开辟失败。基于失败的情况，我们调用一下我们之前学过的字符串函数：strerror函数。这个函数会将错误码转化成
//错误信息。而错误码会存储在errno类型里，所以我们包含一下头文件errno.h，因此，当我们开辟空间失败的时候，就会
//将错误码存储在errno里，然后我们将错误码传入函数strerror中，即可打印空间开辟失败的原因


//free

//int main()
//{
//	int* p = malloc(40);
//	if (p == NULL)
//	{
//		perror("malloc");
//		return 1;
//	}
//	int* ptr = p;
//	for (int i = 0; i < 10; i++)
//	{
//		*(ptr + i) = i;
//	}
//	free(p);
//	p = NULL;
//	ptr = NULL;
//	return 0;
//}
//上面的代码其实和刚才在malloc函数中写的代码几乎是一致的，只不过我们把刚才的strerror函数换成了perror函数，目的就是
//帮助大家回顾一下之前学过的知识。千万要注意，当我们将一段空间释放后，一定要把指向这一段空间的设置为空指针，避免野指针的出现。

//calloc
//我们知道malloc函数仅仅是开辟新的空间，这段空间中存储的数据还是原本的随机值。但是calloc函数可以讲所开辟的空间初始化数据为0。

//realloc
//这个函数也是用来开辟空间的，但是我们很难保证我们开辟的空间是恰好的。所以这个函数的作用就是对我们开辟的空间进行大小上的调整。
//对于情况一而言，这段自己开辟的空间后面多余的空间足够我们的需要，那么这个函数就会在原空间的基础上继续向后开辟，然后最终返回原地址。
//但是，也会出现情况二，即当我们原空间后面的空间不足时，系统会开辟一块新的内存空间，然后将原空间的内容复制过来，再释放原空间。再返回新空间的地址。
//倘若整个内存空间都没有一块空间能够满足我们的需求，此时就会返回一个空指针。
